package funnel.ui {	import flash.events.Event;	import flash.utils.getTimer;	import flash.utils.Timer;	import flash.events.TimerEvent;	import funnel.*;	/**	 * @copy ButtonEvent#PRESS	 */	[Event(name="press",type="ButtonEvent")]	/**	 * @copy ButtonEvent#RELEASE	 */	[Event(name="release",type="ButtonEvent")]	/**	 * @copy ButtonEvent#LONG_PRESS	 */	[Event(name="longPress",type="ButtonEvent")]	/**	 * @copy ButtonEvent#SUSTAINED_PRESS	 */	[Event(name="sustainedPress",type="ButtonEvent")]	/**	 * This is the class to express a generic button	 * 	 * @author Shigeru Kobayashi	 */	public class Button extends PhysicalInput {		public static const PULL_DOWN:uint = 0;		public static const PULL_UP:uint = 1;		private var _pin:Pin;		private var _timer:Timer = null;		private var _debounceInterval:int;		private var _lastPressed:int;		private var _lastReleased:int;		/**		 * 		 * @param buttonPin the pin number for a button		 * @param buttonMode the button mode (PULL_DOWN or PULL_UP)		 * @param longPressDelay the delay time for long press		 * @throws (newArgumentError("buttonMode should be PULL_DOWN or PULL_UP"))		 */		public function Button(buttonPin:Pin, buttonMode:uint = PULL_DOWN, longPressDelay:Number = 1000) {			super();			_pin = buttonPin;			_pin.filters = [new SetPoint([0.5, 0.1])];			if (buttonMode == PULL_DOWN) {				_pin.addEventListener(PinEvent.RISING_EDGE, buttonPressed);				_pin.addEventListener(PinEvent.FALLING_EDGE, buttonReleased);			} else if (buttonMode == PULL_UP) {				_pin.addEventListener(PinEvent.FALLING_EDGE, buttonPressed);				_pin.addEventListener(PinEvent.RISING_EDGE, buttonReleased);			} else {				throw(new ArgumentError("buttonMode should be PULL_DOWN or PULL_UP"));			}			_timer = new Timer(longPressDelay);			_timer.addEventListener(TimerEvent.TIMER, buttonSustainedPress);			_debounceInterval = 20;			_lastPressed = 0;			_lastReleased = 0;		}		/**		 *		 * @param interval set interval for debouncing		 *		 */		public function set debounceInterval(interval:int):void {			_debounceInterval = interval;		}		/**		 *		 * @param interval get interval for debouncing		 *		 */		public function get debounceInterval():int {			return _debounceInterval;		}		private function buttonPressed(e:PinEvent):void {			var now:int = getTimer();			if ((now - _lastPressed) < _debounceInterval) {				return;			}			_lastPressed = now;			dispatchEvent(new ButtonEvent(ButtonEvent.PRESS));			_timer.reset();			if (!_timer.running) {				_timer.start();			}		}		private function buttonReleased(e:PinEvent):void {			var now:int = getTimer();			if ((now - _lastReleased) < _debounceInterval) {				return;			}			if (_timer.running) {				_timer.stop();			}			_lastReleased = now;			dispatchEvent(new ButtonEvent(ButtonEvent.RELEASE));		}		private function buttonSustainedPress(e:TimerEvent):void {			if (_timer.currentCount > 1) {				dispatchEvent(new ButtonEvent(ButtonEvent.SUSTAINED_PRESS));			} else {				dispatchEvent(new ButtonEvent(ButtonEvent.LONG_PRESS));			}		}	}}
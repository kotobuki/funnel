package funnel{	import flash.events.Event;	import flash.events.EventDispatcher;		/**	 * @copy PinEvent#CHANGE	 */	[Event(name="change",type="PinEvent")]		/**	 * @copy PinEvent#RISING_EDGE	 */	[Event(name="risingEdge",type="PinEvent")]		/**	 * @copy PinEvent#FALLING_EDGE	 */	[Event(name="fallingEdge",type="PinEvent")]		/**	 * The Pin class represents the Input and Output pins of the I/O module.	 * 	 * <p>I/Oモジュールの入出力ポートを表すクラスです。</p>	 */ 	public class Pin extends EventDispatcher	{		/**		 * analog input		 */		public static const AIN:uint = 0;		/**		 * digital input		 */		public static const DIN:uint = 1;		/**		 * analog output and pwm output		 */		public static const AOUT:uint = 2;		public static const PWM:uint = AOUT;		/**		 * digital output		 */		public static const DOUT:uint = 3;		/**		 * Pins for servo		 */		public static const SERVO:uint = 4;		/**		 * Pins for I2C		 */		public static const I2C:uint = 6;				private var _value:Number;		private var _lastValue:Number;		private var _preFilterValue:Number;		private var _number:uint;		private var _type:uint; 		private var _filters:Array;		private var _generator:IGenerator;		private var _sum:Number;		private var _average:Number;		private var _minimum:Number;		private var _maximum:Number;		private var _numSamples:Number;		private static const MAX_SAMPLES:Number = Number.MAX_VALUE;				/**		 * 		 * @param number port number		 * @param type port type(AIN、DIN、AOUT/PWM、DOUT, SERVO, I2C)		 * 		 */				public function Pin(number:uint, type:uint) {			_number = number;			_type = type;			_value = 0;			_lastValue = 0;			_minimum = 1;			_maximum = 0;			_average = 0;			_sum = 0;			_numSamples = 0;		}				/**		 * port number		 * <p>ポート番号</p>		 */				public function get number():uint {			return _number;		}				/**		 * port type(AIN, DIN, AOUT/PWM, DOUT, SERVO, I2C)		 * <p>ポートのタイプ(AIN、DIN、AOUT/PWM、DOUT, SERVO, I2C)</p>		 */				public function get type():uint {			return _type;		}				/**		 * Get input from a sensor or actuator. Sets value of a pin from 0.0 to 1.0.		 * <p>センサからの入力値、またはアクチュエータへの出力値</p>		 */				public function get value():Number {			return _value;		}				public function set value(val:Number):void {			calculateMinimumMaximumAndMean(val);			_lastValue = _value;			_preFilterValue = val;			_value = applyFilters(val);			detectEdge(_lastValue, _value);		}		public function get preFilterValue():Number {			return _preFilterValue;		}				/**		 * returns the last set velue		 * <p>ポートの変化する前の値</p>		 */				public function get lastValue():Number {			return _lastValue;		}				/**		 * average value		 * <p>平均値</p>		 */				public function get average():Number {			return _average;		}				/**		 * minimum value		 * <p>最小値</p>		 */				public function get minimum():Number {			return _minimum;		}				/**		 * maximum value		 * <p>最大値</p>		 */				public function get maximum():Number {			return _maximum;		}				/**		 * Get filters for the pin. Set filters for the pin.		 * <p>ポートに適応するフィルタ配列</p>		 */				public function get filters():Array {			return _filters;		}				public function set filters(array:Array):void {			if (_generator != null) {				_generator.removeEventListener(GeneratorEvent.UPDATE, autoSetValue);			}						if (array == null || array.length == 0) {				_filters = array;				return;			}						var lastIndexOfGenerator:uint = 0;			for (var i:int = array.length - 1; i >= 0; --i) {				if (array[i] is IFilter) {					//;				} else if (array[i] is IGenerator) {					lastIndexOfGenerator = i;					_generator = array[i] as IGenerator;					_generator.addEventListener(GeneratorEvent.UPDATE, autoSetValue);					break;				} else {					return;				}			}			_filters = array.slice(lastIndexOfGenerator);		}				/**		 * Add a new filter to the pin		 */		public function addFilter(newFilter:*):void {			if (newFilter == null) {				return;			}			if (_filters == null) {				_filters = new Array();			}			if (newFilter is IFilter) {				//;			} else if (newFilter is IGenerator) {				if (_generator != null) {					_generator.removeEventListener(GeneratorEvent.UPDATE, autoSetValue);				}				_generator = newFilter;				_generator.addEventListener(GeneratorEvent.UPDATE, autoSetValue);			} else {				return;			}			_filters.push(newFilter);		}		/**		 * Sets new filters to the pin		 */		public function setFilters(newFilters:Array):void {			filters = newFilters;		}		/**		 * Removes all filters from the pin		 */		public function removeAllFilters():void {			filters = null;		}		private function autoSetValue(event:Event):void {			value = _generator.value;		}				/**		 * Reset the history.		 * <p>ヒストリをリセットします。</p>		 */				public function clear():void {			_minimum = _maximum = _average = _lastValue = _preFilterValue;			clearWeight();		}				private function clearWeight():void {			_sum = _average;			_numSamples = 1;		}				private function calculateMinimumMaximumAndMean(val:Number):void {			_minimum = Math.min(val, _minimum);			_maximum = Math.max(val, _maximum);						_sum += val;			_average = _sum / (++_numSamples);			if (_numSamples >= MAX_SAMPLES) {				clearWeight();			}		}				private function detectEdge(oldValue:Number, newValue:Number):void {			if (oldValue == newValue) return;			dispatchEvent(new PinEvent(PinEvent.CHANGE));						if (oldValue == 0 && newValue != 0) {				dispatchEvent(new PinEvent(PinEvent.RISING_EDGE));			} else if (oldValue != 0 && newValue == 0) {				dispatchEvent(new PinEvent(PinEvent.FALLING_EDGE));			}		}				private function applyFilters(val:Number):Number {			if (_filters == null) return val;						var result:Number = val;			for (var i:uint = 0; i < _filters.length; ++i) {				if (_filters[i] is IFilter) {					result = _filters[i].processSample(result);				}			}			return result;		}			}}
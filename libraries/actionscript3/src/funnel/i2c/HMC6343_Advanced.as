package funnel.i2c {	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;	import flash.events.TimerEvent;	import flash.utils.Timer;	/**	 * This is the class to express HMC6343 tilt-compensated compass	 * Exposes Heading, Pitch, Roll and Acclerometer X, Y, Z data	 *	 * Created by Jeff Hoefs	 * Modified by Shigeru Kobayashi	 *	 */	public class HMC6343_Advanced extends I2CDevice implements IEventDispatcher {		public static const UPDATE_MODE:uint = 0;		public static const CONTINUOUS_HEADING:uint = 1;		public static const CONTINUOUS_ACCL:uint = 2;		/* Interface Commands */		public static const LEVEL:uint = 0x72;		public static const UPRIGHT_EDGE:uint = 0x73;		public static const UPRIGHT_FRONT:uint = 0x74;		// Measurement rates (for bits 0 and 1 of OP_MODE2)		public static const RATE_10HZ:uint = 0x02;		public static const RATE_5HZ:uint = 0x01;		public static const RATE_1HZ:uint = 0x00;		public static const RATE_NA:uint = 0x03;		private static const NUM_BYTES:uint = 6;		private static const READ_HEADING:uint = 0x50;		private static const READ_ACCL:uint = 0x40;		private static const ENTER_USER_CALIBRATION_MODE:uint = 0x71;		private static const EXIT_USER_CALIBRATION_MODE:uint = 0x7E; // 50ms response time		private static const RESET_THE_PROCESSOR:uint = 0x82; // 500ms response time		private static const ENTER_SLEEP_MODE:uint = 0x83;		private static const EXIT_SLEEP_MODE:uint = 0x84; // 20ms response time		/* Response delay times */		private static const RESPONCE_DELAY_TIME_20MS:uint = 20; // 20ms		private static const RESPONCE_DELAY_TIME_50MS:uint = 50; // 50ms		private static const RESPONCE_DELAY_TIME_500MS:uint = 500; // 500ms				/* EEPROM registers */		private static const OP_MODE2:uint = 0x05;		private var _heading:Number = 0;		private var _pitch:Number = 0;		private var _roll:Number = 0;		private var _xAxis:Number = 0;		private var _yAxis:Number = 0;		private var _zAxis:Number = 0;		private var _dispatcher:EventDispatcher;		private var _runMode:uint;		private var _compassOrientation:uint;		private var _timer:Timer = null;		private var _readOperationsEnabled:Boolean = true;		public function HMC6343_Advanced(ioModule:*, compassOrientation:uint = 0, runMode:uint = 0, address:uint = 0x19, measurementRate:uint = RATE_10HZ) {			super(ioModule, address);			_dispatcher = new EventDispatcher(this);			_runMode = runMode;			if (compassOrientation == 0) {				_compassOrientation = LEVEL;			} else {				setCompassOrientation(compassOrientation);			}			_timer = new Timer(1000, 1);			// set measurement rate (device default is 5hz, but it is set as default to 10hz in this class)			if (measurementRate > 0x03)				measurementRate = RATE_10HZ;			_io.sendSysex(I2C_REQUEST, [WRITE, address, OP_MODE2, measurementRate]);			// can currently only use READ_CONTINUOUS with a singe register			if (_runMode == CONTINUOUS_HEADING) {				_io.sendSysex(I2C_REQUEST, [READ_CONTINUOUS, address, READ_HEADING, 6]);			} else if (_runMode == CONTINUOUS_ACCL) {				_io.sendSysex(I2C_REQUEST, [READ_CONTINUOUS, address, READ_ACCL, 6]);			} else {				_runMode = UPDATE_MODE;			}		}		public function setCompassOrientation(compassOrientation:uint):void {			if (compassOrientation == LEVEL || compassOrientation == UPRIGHT_EDGE || compassOrientation == UPRIGHT_FRONT) {				_compassOrientation = compassOrientation;				_io.sendSysex(I2C_REQUEST, [WRITE, address, _compassOrientation]);			} else {				throw new ArgumentError("Incorrect compass orientation specified, use only 0x72 - 0x74");			}		}		public function updateHeading():void {			if (_runMode == UPDATE_MODE) {				// read heading, pitch, roll				_io.sendSysex(I2C_REQUEST, [READ, address, READ_HEADING, 6]);			} else {				throw new ArgumentError("Cannot call update methods when not in Update Mode");			}		}		public function updateAccl():void {			if (_runMode == UPDATE_MODE) {				// read x, y, z accelerometer data				_io.sendSysex(I2C_REQUEST, [READ, address, READ_ACCL, 6]);			} else {				throw new ArgumentError("Cannot call update methods when not in Update Mode");			}		}		public override function handleSysex(command:uint, data:Array):void {			var x_val:int, y_val:int, z_val:int;			var pitch_val:int, roll_val:int;			if (command != I2C_REPLY) {				return;			}			if (data.length != NUM_BYTES + 2) {				throw new ArgumentError("Incorrecte number of bytes returned");				return;			}			if (data[1] == READ_HEADING) {				// 360.0 degrees				_heading = (int(data[2]) << 8) | (int(data[3]));				// 90.0 degrees				pitch_val = (int(data[4]) << 8) | (int(data[5]));				// according to the datasheet, roll should be in the range of +/- 90				// however the range is actually +/- 180 degrees				roll_val = (int(data[6]) << 8) | (int(data[7]));				if (roll_val >> 15) {					_roll = ((roll_val ^ 0xFFFF) + 1) * -1;				} else					_roll = roll_val;				if (pitch_val >> 15) {					_pitch = ((pitch_val ^ 0xFFFF) + 1) * -1;				} else					_pitch = pitch_val;				// To Do: pass values through event?				dispatchEvent(new HMC6343Event(HMC6343Event.HMC6343_HEADING));			}			if (data[1] == READ_ACCL) {				x_val = (int(data[2]) << 8) | (int(data[3]));				y_val = (int(data[4]) << 8) | (int(data[5]));				z_val = (int(data[6]) << 8) | (int(data[7]));				if (x_val >> 15) {					_xAxis = ((x_val ^ 0xFFFF) + 1) * -1;				} else					_xAxis = x_val;				if (y_val >> 15) {					_yAxis = ((y_val ^ 0xFFFF) + 1) * -1;				} else					_yAxis = y_val;				if (z_val >> 15) {					_zAxis = ((z_val ^ 0xFFFF) + 1) * -1;				} else					_zAxis = z_val;				// To Do: pass values through event?				dispatchEvent(new HMC6343Event(HMC6343Event.HMC6343_ACCL));			}		}		public function enterUserCalibrationMode():void {			_io.sendSysex(I2C_REQUEST, [WRITE, address, ENTER_USER_CALIBRATION_MODE]);		}		public function exitUserCalibrationMode():void {			_readOperationsEnabled = false;			if (_runMode != UPDATE_MODE) {				_io.sendSysex(I2C_REQUEST, [STOP_READING, address]);			}			_io.sendSysex(I2C_REQUEST, [WRITE, address, EXIT_USER_CALIBRATION_MODE]);			_timer.reset();			_timer.delay = RESPONCE_DELAY_TIME_50MS;			_timer.addEventListener(TimerEvent.TIMER_COMPLETE, onReadyToReEnableReadOperations);			_timer.start();		}		public function resetTheProcessor():void {			_readOperationsEnabled = false;			if (_runMode != UPDATE_MODE) {				_io.sendSysex(I2C_REQUEST, [STOP_READING, address]);			}			_io.sendSysex(I2C_REQUEST, [WRITE, address, RESET_THE_PROCESSOR]);			_timer.reset();			_timer.delay = RESPONCE_DELAY_TIME_500MS;			_timer.addEventListener(TimerEvent.TIMER_COMPLETE, onReadyToReEnableReadOperations);			_timer.start();		}		private function onReadyToReEnableReadOperations(e:TimerEvent):void {			_timer.removeEventListener(TimerEvent.TIMER_COMPLETE, onReadyToReEnableReadOperations);			_readOperationsEnabled = true;			if (_runMode == CONTINUOUS_HEADING) {				_io.sendSysex(I2C_REQUEST, [READ_CONTINUOUS, address, READ_HEADING, 6]);			} else if (_runMode == CONTINUOUS_ACCL) {				_io.sendSysex(I2C_REQUEST, [READ_CONTINUOUS, address, READ_ACCL, 6]);			}		}		public function enterSleepMode():void {			// Important: user must stop calls to update prior to calling this method			_readOperationsEnabled = false;			if (_runMode != UPDATE_MODE) {				_io.sendSysex(I2C_REQUEST, [STOP_READING, address]);			}			_io.sendSysex(I2C_REQUEST, [WRITE, address, ENTER_SLEEP_MODE]);		}		public function exitSleepMode():void {			// should be fast enough.. need to test			_io.sendSysex(I2C_REQUEST, [WRITE, address, EXIT_SLEEP_MODE]);			_timer.reset();			_timer.delay = RESPONCE_DELAY_TIME_20MS;			_timer.addEventListener(TimerEvent.TIMER_COMPLETE, onReadyToReEnableReadOperations);			_timer.start();		}		public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void {			_dispatcher.addEventListener(type, listener, useCapture, priority);		}		public function dispatchEvent(evt:Event):Boolean {			return _dispatcher.dispatchEvent(evt);		}		public function hasEventListener(type:String):Boolean {			return _dispatcher.hasEventListener(type);		}		public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void {			_dispatcher.removeEventListener(type, listener, useCapture);		}		public function willTrigger(type:String):Boolean {			return _dispatcher.willTrigger(type);		}		public function get compassOrientation():uint {			return _compassOrientation;		}		/* Heading, Pitch, Roll */		public function get heading():Number {			return _heading / 10.0; // 0.0 to 360.0		}		public function get pitch():Number {			return _pitch / 10.0; // -90.0 to 90.0		}		public function get roll():Number {			return _roll / 10.0; // -180.0 to 180.0		}		/* Accelerometer X, Y, Z */		// Note, the following values never get to -1.0 or 1.0		public function get x():Number {			// return value between -1.0 and 1.0			return _xAxis / 16384;		}		public function get y():Number {			// return value between -1.0 and 1.0			return _yAxis / 16384;		}		public function get z():Number {			// return value between -1.0 and 1.0			return _zAxis / 16384;		}	}}
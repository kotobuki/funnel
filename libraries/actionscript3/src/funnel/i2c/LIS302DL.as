package funnel.i2c {	import flash.events.IEventDispatcher;	import flash.events.EventDispatcher;	import flash.events.Event;	import funnel.i2c.I2CDevice;	/**	 * This is the class to express a LIS302DL 3-axis accelerometer	 *	 * @author Kazushi Mukaiyama	 * @author Jeff Hoefs	 */	public class LIS302DL extends I2CDevice implements IEventDispatcher {		private static const ALL_AXIS:uint = 0x28 | 0x80;		private static const CTRL_REG1:uint = 0x20;		private static const CTRL_REG2:uint = 0x21;		private static const NUM_BYTES:uint = 6;		private var _x:Number = 0;		private var _y:Number = 0;		private var _z:Number = 0;		private var _address:uint;		private var _isReadContinuous:Boolean;		private var _dispatcher:EventDispatcher;		public function LIS302DL(ioModule:*, isReadContinuous:Boolean = true, address:uint = 0x1D) {			super(ioModule, address);			_address = address;			_isReadContinuous = isReadContinuous;			_dispatcher = new EventDispatcher(this);			/* Initiate device */			/* 0 - data rate selection, 1=100Hz			   1 - power down control, 1 = active mode			   0 - full scale selection, 0 = +/- 2g, 1 = +/- 8g			   0 - self test P enable, 0 = normal mode			   0 - self test M enabled, 0 = normal mode			   1 - z axis enable, 1 = enabled			   1 - y axis enable, 1 = enabled			   1 - x axis enable, 1 = enabled			*/			_io.sendSysex(I2C_REQUEST, [WRITE, address, CTRL_REG1, 0x47]);			/* 0 - SPI mode selection			   1 - reboot memory contents			   0 - none			   0 - filtered data selection, 0 = bypassed			   0 - high pass filter enable for freefall/wakeup #2, 0 = bypassed			   0 - high pass filter enable for freefall/wakeup #1, 0 = bypassed			   0 - high pass coefficient 2			   0 - high pass coefficient 1			   the last 2 bits configure the high pass filter cutoff frequency			*/			_io.sendSysex(I2C_REQUEST, [WRITE, address, CTRL_REG2, 0x40]);			if(_isReadContinuous) {				_io.sendSysex(I2C_REQUEST, [READ_CONTINUOUS, address, ALL_AXIS, 6]);			}		}		public override function update():void {			// read data: contents of X, Y, and Z registers			if(!_isReadContinuous) {				_io.sendSysex(I2C_REQUEST, [READ, address, ALL_AXIS, 6]);			} else {				throw new ArgumentError("Cannot call update method when Read Continuous is set to true");			}		}		public override function handleSysex(command:uint, data:Array):void {			var x_val:int, y_val:int, z_val:int;			if (command != I2C_REPLY) {				return;			}			if (data.length != NUM_BYTES + 2) {				throw new ArgumentError("Incorrecte number of bytes returned");				return;			}			x_val =(int(data[3]));			y_val =(int(data[5]));			z_val =(int(data[7]));			// j. hoefs 6/19/09 - changed these equations to return exactly -1.0 to 1.0			if(x_val >> 7) {				_x = ((x_val ^ 0xFF)) * -1;			} else _x = x_val;			if(y_val >> 7) {				_y = ((y_val ^ 0xFF)) * -1;			} else _y = y_val;			if(z_val >> 7) {				_z = ((z_val ^ 0xFF)) * -1;			} else _z = z_val;			dispatchEvent(new Event(Event.CHANGE));		}		public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void{			_dispatcher.addEventListener(type, listener, useCapture, priority);		}		public function dispatchEvent(evt:Event):Boolean{			return _dispatcher.dispatchEvent(evt);		}		public function hasEventListener(type:String):Boolean{			return _dispatcher.hasEventListener(type);		}		public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void{			_dispatcher.removeEventListener(type, listener, useCapture);		}		public function willTrigger(type:String):Boolean {			return _dispatcher.willTrigger(type);		}		public function get x():Number {			//divide to return value between -1.0 and 1.0			return _x/127;		}		public function get y():Number {			//divide to return value between -1.0 and 1.0			return _y/127;		}		public function get z():Number {			//divide to return value between -1.0 and 1.0			return _z/127;		}	}}
package funnel.i2c {	import flash.events.IEventDispatcher;	import flash.events.EventDispatcher;	import flash.events.Event;	import funnel.i2c.I2CDevice;	/**	 * j. hoefs 4/9/08	 * This is the class to express a LIS3LV02DQ 3-axis accelerometer	 */	 	public class LIS3LV02DQ extends I2CDevice implements IEventDispatcher {				private static const ALL_AXIS:uint = 0x28 | 0x80;		private static const NUM_BYTES:uint = 6;		private var _x:Number = 0;		private var _y:Number = 0;		private var _z:Number = 0;				private var _address:uint;		private var _isReadContinuous:Boolean;				private var _dispatcher:EventDispatcher; 		public function LIS3LV02DQ(ioModule:*, isReadContinuous:Boolean = true, address:uint = 0x1D) {			super(ioModule, address);						_address = address;			_isReadContinuous = isReadContinuous;						_dispatcher = new EventDispatcher(this);						/* Initiate device */			// Device on, 40hz, normal mode, all axis's enabled			_io.sendSysex(I2C_REQUEST, [WRITE, address, 0x20, 0x87]);			// Enable BDU bit to block data update until both MSB and LSB are read			_io.sendSysex(I2C_REQUEST, [WRITE, address, 0x21, 0x40]);						if(_isReadContinuous) {				_io.sendSysex(I2C_REQUEST, [READ_CONTINUOUS, address, ALL_AXIS, 6]);			}		}		public override function update():void {			// read data: contents of X, Y, and Z registers			if(!_isReadContinuous) {				_io.sendSysex(I2C_REQUEST, [READ, address, ALL_AXIS, 6]);			} else {				throw new ArgumentError("Cannot call update method when Read Continuous is set to true");			}		}		public override function handleSysex(command:uint, data:Array):void {			var x_val:int, y_val:int, z_val:int;						if (command != I2C_REPLY) {				return;			}			if (data.length != NUM_BYTES + 2) {				throw new ArgumentError("Incorrecte number of bytes returned");				return;			}						// little endian (BLE = 0 in CTRL_REG2 (0x21)) 			x_val = (int(data[3]) << 8) | (int(data[2]));			y_val = (int(data[5]) << 8) | (int(data[4]));			z_val = (int(data[7]) << 8) | (int(data[6]));							if(x_val >> 15) {				_x = ((x_val ^ 0xFFFF) + 1) * -1;			} else _x = x_val;			if(y_val >> 15) {				_y = ((y_val ^ 0xFFFF) + 1) * -1;			} else _y = y_val;			if(z_val >> 15) {				_z = ((z_val ^ 0xFFFF) + 1) * -1;			} else _z = z_val;						dispatchEvent(new Event(Event.CHANGE));					}				public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void{			_dispatcher.addEventListener(type, listener, useCapture, priority);		}			   		public function dispatchEvent(evt:Event):Boolean{			return _dispatcher.dispatchEvent(evt);		}				public function hasEventListener(type:String):Boolean{			return _dispatcher.hasEventListener(type);		}				public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void{			_dispatcher.removeEventListener(type, listener, useCapture);		}					   		public function willTrigger(type:String):Boolean {			return _dispatcher.willTrigger(type);		}				public function get x():Number {			//divide by 2047 to return value between -1.0 and 1.0			return _x/2047;		}				public function get y():Number {			//divide by 2047 to return value between -1.0 and 1.0			return _y/2047;		}				public function get z():Number {			//divide by 2047 to return value between -1.0 and 1.0			return _z/2047;		}	}}
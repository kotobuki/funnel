package funnel.i2c {	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;		import funnel.i2c.I2CDevice;	/**	 * This is the class to express a LIS3LV02DQ 3-axis accelerometer	 *	 * Jeff Hoefs 4/9/09	 * revised 3/5/2011 to expose acceleration values in Gs and allow	 * user to choose from +-2G (default) or +-6G dynamic ranges	 */	 	public class LIS3LV02DQ extends I2CDevice implements IEventDispatcher {				public static const RANGE_2G:Number = 2;		public static const RANGE_6G:Number = 6;		public static const DEVICE_ID:uint = 0x1D;		private static const ALL_AXIS:uint = 0x28 | 0x80;		private static const NUM_BYTES:uint = 6;				private static const CTRL_REG1:uint = 0x20;		private static const CTRL_REG2:uint = 0x21;				private var _x:Number = 0;		private var _y:Number = 0;		private var _z:Number = 0;				private var _dynamicRange:Number;		private var _sensitivity:Number;				private var _address:uint;		private var _isReading:Boolean = false;						private var _dispatcher:EventDispatcher;				// debug mode 				private var _debugMode : Boolean = true;		  		/**		 * @param	ioModule	A funnel io module such as an instance of a fio or arduino		 * @param	autoStart	True if read continuous mode should start automatically upon instantiation (default is false)		 * @param	address		The i2c address of the accelerometer (default is 0x1D)		 * @param	range		The dynamic range selection in Gs for this accelerometer (options RANGE_2G or RANGE_6G). Default is RANGE_2G.		 */		public function LIS3LV02DQ(ioModule:*, autoStart:Boolean = false, address:uint = DEVICE_ID, range:Number = RANGE_2G) {			super(ioModule, address);						_address = address;			_dynamicRange = range;						_dispatcher = new EventDispatcher(this);						/* Initiate device */			// Device on, 40hz, normal mode, all axis's enabled			_io.sendSysex(I2C_REQUEST, [WRITE, address, CTRL_REG1, 0x87]);						// Enable BDU bit to block data update until both MSB and LSB are read			if( _dynamicRange == 2 ) {				// dynamic range is +- 2g				_io.sendSysex(I2C_REQUEST, [WRITE, address, CTRL_REG2, 0x40]);				_sensitivity = 1024;			} else {				_dynamicRange = 6; // make sure dynamic range is 6 Gs in case user passes invalid value				// set dynamic range to +- 6g				_io.sendSysex(I2C_REQUEST, [WRITE, address, CTRL_REG2, 0xC0]);				_sensitivity = 340;			}						if(autoStart) {				startReading();			}		}				/** 		 * Sends read request to accelerometer and updates accelerometer values.		 */		public override function update():void {						if(_isReading) {				stopReading();				}			// read data: contents of X, Y, and Z registers			_io.sendSysex(I2C_REQUEST, [READ, _address, ALL_AXIS, 6]);		}				/**		 * @private		 */		public override function handleSysex(command:uint, data:Array):void {			var x_val:int, y_val:int, z_val:int;						if (command != I2C_REPLY) {				return;			}			if (data.length != NUM_BYTES + 2) {				throw new ArgumentError("Incorrecte number of bytes returned");				return;			}						// little endian (BLE = 0 in CTRL_REG2 (0x21)) 			x_val = (int(data[3]) << 8) | (int(data[2]));			y_val = (int(data[5]) << 8) | (int(data[4]));			z_val = (int(data[7]) << 8) | (int(data[6]));							if(x_val >> 15) {				_x = ((x_val ^ 0xFFFF) + 1) * -1;			} else _x = x_val;			if(y_val >> 15) {				_y = ((y_val ^ 0xFFFF) + 1) * -1;			} else _y = y_val;			if(z_val >> 15) {				_z = ((z_val ^ 0xFFFF) + 1) * -1;			} else _z = z_val;						dispatchEvent(new Event(Event.CHANGE));					}				/**		 * Get state of continuous read mode. If true, continuous read mode		 * is enabled, if false, it is disabled.		 */		public function get isRunning():Boolean {			return _isReading;		}							/**		 * start continuous reading of the sensor		 */				public function startReading():void {			if (!_isReading) {				_isReading = true;				_io.sendSysex(I2C_REQUEST, [READ_CONTINUOUS, _address, ALL_AXIS, 6]);							}		}				/**		 * stop continuous reading of the sensor		 */					public function stopReading():void {			_isReading = false;			_io.sendSysex(I2C_REQUEST, [STOP_READING, _address]);		}						/** returns the accelerometer dynamic range in Gs (either 2G or 6G for this		 *  particular sensor).		 */		public function get dynamicRange():Number {			return _dynamicRange;		}				/** returns raw x acceleration value from sensor		 */		public function get rawX():Number {			return _x;		}				/** returns raw y acceleration value from sensor		 */		public function get rawY():Number {			return _y;		}				/** returns raw z acceleration value from sensor		 */		public function get rawZ():Number {			return _z;		}				/** returns the acceleration value in Gs (9.8m/sec^2) along the x-axis		 */		public function get x():Number {			// return acceleration in Gs			return _x/_sensitivity;		}		/** returns the acceleration value in Gs (9.8m/sec^2) along the y-axis		 */		public function get y():Number {			// return acceleration in Gs			return _y/_sensitivity;		}		/** returns the acceleration value in Gs (9.8m/sec^2) along the z-axis		 */		public function get z():Number {			// return acceleration in Gs			return _z/_sensitivity;		}						/* implement EventDispatcher */				public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void{			_dispatcher.addEventListener(type, listener, useCapture, priority);		}			   		public function dispatchEvent(evt:Event):Boolean{			return _dispatcher.dispatchEvent(evt);		}				public function hasEventListener(type:String):Boolean{			return _dispatcher.hasEventListener(type);		}				public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void{			_dispatcher.removeEventListener(type, listener, useCapture);		}					   		public function willTrigger(type:String):Boolean {			return _dispatcher.willTrigger(type);		}				// for debugging 		private function debug ( str:String ) : void {			if ( _debugMode ) {				trace(str); 			}		}			}}
package funnel{	import flash.utils.*;	import flash.events.TimerEvent;	import flash.events.Event;	import flash.events.EventDispatcher;		/**	 * @copy GeneratorEvent#UPDATE	 */	[Event(name="update",type="GeneratorEvent")]		/**	 * Osc outputs a waveform on the associated PWM pin. For example, this can be used to blink or fade	 * an LED on or off.	 * 	 * <p>LEDをふわふわ点滅させたりする時などに使います。回数を1回に設定すると、ワンショットの制御にも使えます。サービス間隔はOsc.serviceIntervalの設定に従います。</p>	 * 	 */ 	public class Osc extends EventDispatcher implements IGenerator	{			/**		 * wave function		 * <p>波形の関数</p>		 * @default Osc.SIN		 */				public var wave:Function;				/**		 * frequency		 * <p>周波数</p>		 * @default 1		 */				public var freq:Number;				/**		 * amplitude		 * <p>振幅</p>		 * @default 1		 */				public var amplitude:Number;				/**		 * offset		 * <p>オフセット</p>		 * @default 0		 */				public var offset:Number;				/**		 * phase		 * <p>位相</p>		 * @default 0		 */				public var phase:Number;				/**		 * repeat count from 0 to infinite times		 * <p>リピート回数(0で無限回)</p>		 * @default 0		 */				public var times:Number;				private var _time:uint;		private var _startTime:int;		private var _value:Number;		private var _lastVal:Number;			private static var _timer:Timer = function():Timer {			var timer:Timer = new Timer(33);			timer.start();			return timer;		}();				/**		 * sets the service interval in milliseconds		 * 		 * <p>サービス間隔(ms)</p>		 * 		 */				public static function set serviceInterval(interval:uint):void {			_timer.delay = interval;		}				public static function get serviceInterval():uint {			return _timer.delay;		}				/**		 * 		 * @param wave waveform		 * @param freq frequency		 * @param amplitude amplitude		 * @param offset offset		 * @param phase phase		 * @param times repeat count		 * 		 */				public function Osc(			wave:Function = null,			freq:Number = 1,			amplitude:Number = 1,			offset:Number = 0,			phase:Number = 0,			times:Number = 0		) {			if (freq == 0) throw new Error("Frequency should be larger than 0...");						if (wave == null) this.wave = SIN;			else this.wave = wave;						this.freq = freq;			this.amplitude = amplitude;			this.offset = offset;			this.phase = phase;			this.times = times;						reset();		}				/**		 * @inheritDoc		 */				public function get value():Number {			return _value;		}				/**		 * starts oscillator		 * 		 * <p>Oscの動作を開始します。</p>		 * 		 */				public function start():void {			stop();			_timer.addEventListener(TimerEvent.TIMER, autoUpdate);			_startTime = getTimer();			autoUpdate(null);		}				/**		 * stops oscillator		 * 		 * <p>Oscの動作を停止します。</p>		 * 		 */				public function stop():void {			_timer.removeEventListener(TimerEvent.TIMER, autoUpdate);		}				/**		 * resets oscillator		 * 		 * <p>Oscの状態をリセットします。</p>		 * 		 */				public function reset():void {			_time = 0;			_lastVal = 0.999;		}				/**		 * By default the interval is 33 milliseconds. The Osc is updated every 33ms.		 * 		 * <p>指定したインターバルだけ時間を進めます。引数を省略するとOsc.serviceIntervalだけ時間を進めます。</p>		 * @param interval update interval in milliseconds		 */				public function update(interval:int = -1):void {			if (interval < 0) _time += _timer.delay;			else _time += interval;						computeValue();		}				private function autoUpdate(event:Event):void {			_time = getTimer() - _startTime;			computeValue();		}				private function computeValue():void {			var sec:Number = _time / 1000;						if (times != 0 && freq * sec >= times) {				stop();				sec = times / freq;				if (wave != LINEAR) {					_value = offset;				} else {					_value = amplitude * wave(1, 0) + offset;				}			} else {				var val:Number = freq * (sec + phase);				_value = amplitude * wave(val, _lastVal) + offset;				_lastVal = val;			}			dispatchEvent(new GeneratorEvent(GeneratorEvent.UPDATE));		}				/**		 * sine wave		 * <p>サイン波</p>		 * 		 */				public static function SIN(val:Number, lastVal:Number):Number {			return 0.5 * (1 + Math.sin(2 * Math.PI * (val - 0.25)));		}				/**		 * square wave		 * <p>矩形波</p>		 * 		 */				public static function SQUARE(val:Number, lastVal:Number):Number {			return (val%1 <= 0.5) ? 1 : 0;		}				/**		 * triangle wave		 * <p>三角波</p>		 * 		 */ 		public static function TRIANGLE(val:Number, lastVal:Number):Number {			val %= 1;			return (val <= 0.5) ? (2 * val) : (2 - 2 * val);		}				/**		 * saw wave		 * <p>ノコギリ波</p>		 * 		 */ 		public static function SAW(val:Number, lastVal:Number):Number {			val %= 1;			if (val <= 0.5) return val + 0.5;			else return val - 0.5;		}				/**		 * impulse		 * 		 */ 		public static function IMPULSE(val:Number, lastVal:Number):Number {			return ((val % 1) < (lastVal % 1)) ? 1 : 0;		}		/**		 * linear		 * 		 */ 		public static function LINEAR(val:Number, lastVal:Number):Number {			return (val <= 1) ? val : 1;		}	}}
package funnel {	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import funnel.osc.*;	/**	 * @copy FunnelEvent#READY	 */	[Event(name="ready",type="FunnelEvent")]	/**	 * @copy FunnelEvent#I2C_POWER_PINS_READY	 */	[Event(name="i2cPowerPinsReady",type="FunnelEvent")]	/**	 * @copy FunnelEvent#FIRMATA_STRING	 */	[Event(name="firmataString",type="FunnelEvent")]	/**	 * @copy FunnelErrorEvent#ERROR	 */	[Event(name="error",type="FunnelErrorEvent")]	/**	 * @copy FunnelErrorEvent#CONFIGURATION_ERROR	 */	[Event(name="configurationError",type="FunnelErrorEvent")]	/**	 * @copy FunnelErrorEvent#REBOOT_ERROR	 */	[Event(name="rebootError",type="FunnelErrorEvent")]	/**	 * IOSystem for a module (Arduino, Fio, XBee, etc).	 * 	 * <p>複数のI/Oモジュールから構成されるシステムを表現するためのクラスです。</p>	 */	public class IOSystem extends EventDispatcher {		/**		 * Set to false if you want to manually update the output port.		 * 		 * <p>出力ポートを手動で更新する場合はfalseにします。</p>		 * @default true		 */		public var autoUpdate:Boolean;		/**		 * If using I2C power pins, this is time duration for the pin change to settle on the IO module		 */		protected static const I2C_POWER_PINS_STARTUP_TIME:uint = 500;	// 500ms		private var _modules:Object;		private var _commandPort:CommandPort;		private var _samplingInterval:int;		private var _task:Task;		private var _host:String;		private var _portNum:Number;		/**		 * @param configs Configuration array		 * @param host host number		 * @param portNum port number		 * @param samplingInterval sampling interval in milliseconds		 */		public function IOSystem(configs:Array, host:String = "localhost", portNum:Number = 9000, samplingInterval:int = 33) {			autoUpdate = true;			_modules = {};			_commandPort = new CommandPort();			_commandPort.socket.addEventListener(Event.CONNECT, onSocketConnect);			_task = new Task().complete();			_task.addCallback(_commandPort.connect, host, portNum);			_task.addCallback(sendInitCommands, new FunnelEvent(FunnelEvent.READY));			_host = host;			_portNum = portNum;			for each (var config:Configuration in configs) {				var id:uint = config.moduleID;				_modules[id] = new IOModule(this, config);			}			this.samplingInterval = samplingInterval;		}		private function sendInitCommands(e:Event):void {			sendReset();			_commandPort.addEventListener(Event.CHANGE, onReceiveInput);			_commandPort.addEventListener(SysexEvent.SYSEX, onSysexMessage);			for each (var ioModule:IOModule in _modules) {				sendConfiguration(ioModule.id, ioModule.configuration.config);			}			sendPolling(true);			_task.addCallback(dispatchEvent, new FunnelEvent(FunnelEvent.READY));			_task.addErrback(dispatchEvent);		}		private function onSocketConnect(e:Event):void {			dispatchEvent(e);		}		/**		 * Returns a reference to the IOModule associated with the specified module number.		 * <p>moduleNumで指定した番号のI/Oモジュールを取得します。</p>		 * 		 * @param moduleNum The IO module number。Specify the same ID as the Configuration#moduleID.		 * @return moduleNum IOModule object for the specified number		 * @see IOModule		 * @see Configuration#moduleID		 */		public function ioModule(moduleNum:uint):IOModule {			return _modules[moduleNum];		}		/**		 * sampling interval in milliseconds		 * 		 * <p>サンプリング間隔</p>		 * @default 33		 */		public function get samplingInterval():int {			return _samplingInterval;		}		public function set samplingInterval(val:int):void {			_samplingInterval = val;			sendSamplingInterval(val);		}		/**		 * Update the value of all output ports. Usually, set autoUpdate to false in order to use this method.		 * 		 * <p>全ての出力ポートの値を更新します。通常、autoUpdateをfalseに設定して利用します。</p>		 * @see IOSystem#autoUpdate		 */		public function update():void {			for each (var module:IOModule in _modules) {				module.update();			}		}		private function onReceiveInput(event:Event):void {			var message:OSCMessage = _commandPort.inputMessage;			var data:Array = message.value;			var module:IOModule = _modules[data.shift()];			module.handleInput(data);		}		private function onSysexMessage(event:Event):void {			var message:OSCMessage = _commandPort.inputMessage;			var sysexMessage:Array = message.value;			var module:IOModule = _modules[sysexMessage.shift()];			var command:uint = sysexMessage.shift();			module.handleSysex(command, sysexMessage);		}		private function sendReset():void {			_task.addCallback(_commandPort.writeCommand, new OSCMessage("/reset"));		}		private function sendConfiguration(moduleNum:uint, config:Array):void {			var msg:OSCMessage = new OSCMessage("/configure", new OSCInt(moduleNum));			for each (var pinType:uint in config) {				msg.addValue(new OSCInt(pinType));			}			_task.addCallback(_commandPort.writeCommand, msg);		}		private function sendSamplingInterval(interval:int):void {			_task.addCallback(_commandPort.writeCommand, new OSCMessage("/samplingInterval", new OSCInt(interval)));		}		private function sendPolling(enabled:Boolean):void {			_task.addCallback(_commandPort.writeCommand, new OSCMessage("/polling", new OSCInt(enabled ? 1 : 0)));		}		/**		 * @private		 */		internal function sendOut(moduleNum:uint, pinNum:uint, pinValues:Array):void {			var message:OSCMessage = new OSCMessage("/out", new OSCInt(moduleNum), new OSCInt(pinNum));			for (var i:uint = 0; i < pinValues.length; ++i) {				message.addValue(new OSCFloat(pinValues[i]));			}			_task.addCallback(_commandPort.writeCommand, message);		}		internal function sendSysex(moduleNum:uint, command:uint, sysexMessage:Array):void {			var message:OSCMessage = new OSCMessage("/sysex/request", new OSCInt(moduleNum), new OSCInt(command));			for (var i:uint = 0; i < sysexMessage.length; ++i) {				message.addValue(new OSCInt(sysexMessage[i]));			}			_task.addCallback(_commandPort.writeCommand, message);		}	}}
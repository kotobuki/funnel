package funnel.ui {	import flash.events.Event;	import flash.utils.getTimer;	import flash.utils.Timer;	import flash.events.TimerEvent;	import funnel.*;	/**	 * @copy ButtonEvent#PRESS	 */	[Event(name="press",type="ButtonEvent")]	/**	 * @copy ButtonEvent#RELEASE	 */	[Event(name="release",type="ButtonEvent")]	/**	 * @copy ButtonEvent#LONG_PRESS	 */	[Event(name="longPress",type="ButtonEvent")]	/**	 * @copy ButtonEvent#SUSTAINED_PRESS	 */	[Event(name="sustainedPress",type="ButtonEvent")]	/**	 * This is the class to express a generic button	 * 	 * @author Shigeru Kobayashi	 */	public class Button extends PhysicalInput {		public static const PULL_DOWN:uint = 0;		public static const PULL_UP:uint = 1;				private static const PRESSED:uint = 0;		private static const RELEASED:uint = 1;		private var _pin:Pin;		private var _timer:Timer = null;		private var _debounceTimer:Timer;		private var _debounceInterval:int;				private var _state:int = -1;		/**		 * 		 * @param buttonPin a reference to the pin object the button is connected to		 * @param buttonMode the button mode (PULL_DOWN or PULL_UP)		 * @param longPressDelay the delay time for long press		 * @throws (newArgumentError("buttonMode should be PULL_DOWN or PULL_UP"))		 */		public function Button(buttonPin:Pin, buttonMode:uint = PULL_DOWN, longPressDelay:Number = 1000) {			super();			_pin = buttonPin;			_pin.filters = [new SetPoint([0.5, 0.1])];			if (buttonMode == PULL_DOWN) {				_pin.addEventListener(PinEvent.RISING_EDGE, buttonPressed);				_pin.addEventListener(PinEvent.FALLING_EDGE, buttonReleased);			} else if (buttonMode == PULL_UP) {				_pin.addEventListener(PinEvent.FALLING_EDGE, buttonPressed);				_pin.addEventListener(PinEvent.RISING_EDGE, buttonReleased);			} else {				throw(new ArgumentError("buttonMode should be PULL_DOWN or PULL_UP"));			}			_timer = new Timer(longPressDelay);			_timer.addEventListener(TimerEvent.TIMER, buttonSustainedPress);						_debounceInterval = 10;						_debounceTimer = new Timer(_debounceInterval, 1);			_debounceTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onDebounce);					}		/**		 *		 * @param interval set interval for debouncing		 *		 */		public function set debounceInterval(interval:int):void {			_debounceTimer.delay = interval;			_debounceInterval = interval;		}		/**		 *		 * @return interval get interval for debouncing		 *		 */		public function get debounceInterval():int {			return _debounceInterval;		}		private function buttonPressed(e:PinEvent):void {			_debounceTimer.reset();			_debounceTimer.start();			_state = PRESSED;		}		private function buttonReleased(e:PinEvent):void {			_debounceTimer.reset();			_debounceTimer.start();						_state = RELEASED;		}		private function buttonSustainedPress(e:TimerEvent):void {			if (_timer.currentCount > 1) {				dispatchEvent(new ButtonEvent(ButtonEvent.SUSTAINED_PRESS));			} else {				dispatchEvent(new ButtonEvent(ButtonEvent.LONG_PRESS));			}		}				private function onDebounce(e:TimerEvent):void {			if (_state == PRESSED) {				_timer.reset();				if (!_timer.running) {					_timer.start();				}				dispatchEvent(new ButtonEvent(ButtonEvent.PRESS));			} else if (_state == RELEASED) {				if (_timer.running) {					_timer.stop();				}				dispatchEvent(new ButtonEvent(ButtonEvent.RELEASE));			}		}	}}